\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Thesis Proposal}
\author{Elijah Rivera}
\date{November 2019}

\begin{document}

\maketitle

\section{Abstract}

\section{Introduction}
\subsection{Threat Model?}
A.k.a. scare tactics

\subsection{Common errors}

\begin{enumerate}
    \item Memory errors
        \begin{itemize}
            \item Null dereference
            \item Use-after-free
            \item Aliasing/Mutation (race conditions)
        \end{itemize}
    \item Data races
    \item Dangers of having these problems
\end{enumerate}

In the past decade, memory errors have comprised $\sim70\%$ of discovered vulnerabilities. These errors includes (but is not limited to) dereferencing null pointers, accessing memory after it has been deallocated/freed (also known as use-after-free), or accessing memory before it has been initialized. 

Concurrent programs also have additional opportunities for error with data races (explain data races here).

Reasoning about these errors is difficult. Tools continue to be developed which help in detecting/mitigating these errors, but we still continue to see memory errors and data races in software systems of every scale. We also see how these errors can be exploited into large vulnerabilities. (give examples here)

\subsection{Rust}
\begin{enumerate}
    \item Safety model
    \item Memory safety as type safety, statically check
\end{enumerate}

The programming language Rust has recently seen increased usage in the computer systems community because it claims to statically prevent the above errors. Specifically, the developers claim that (quote the nomicon here).

(Rust's approach to memory safety)

(Rust's approach to lifetimes)

Because these are encoded into the type system, we can statically type-check our program. If the program passes, then the memory and lifetime guarantees must hold and our program is memory safe.

\subsection{Unsafe Rust}
\begin{enumerate}
    \item Syntactic restrictions prevent low-level programming paradigms
    \item Unsafe as an escape hatch
    \item Brings us back to C levels of safety (so none)
\end{enumerate}

Low-level systems code has operations that would break these syntactic restrictions. For operating systems (the context for the rest of this paper), these include (types of Unsafe Rust). These operations are restricted by the type-checker and therefore do not compile. Rust provides a backdoor in the form of the keyword "unsafe".

\subsection{RustBelt}
\begin{enumerate}
    \item First, is (safe) Rust as safe as it claims to be?
    \item Is the Rust "extensible" model of safety valid for unsafe programs as well?
    \item Syntactic vs. semantic correctness
\end{enumerate}

\subsection{Our contribution}
\begin{enumerate}
    \item Patterns of Unsafe Rust in systems code
    \item Verified implementation for ZKOS (data structures, other)
    \item ??
\end{enumerate}

\section{Background}
\subsection{Safety of Rust}
\begin{enumerate}
    \item In-depth safety model
    \begin{itemize}
        \item Memory safety as type safety
        \item Static checking/guarantees
        \item Limitations
        \item Restrictions
    \end{itemize}
    \item Proven correct by RustBelt
    \begin{itemize}
        \item This is a stronger claim than what is actually true. This paragraph should talk about what RustBelt actually verifies, and why that's still enough for us.
    \end{itemize}
\end{enumerate}

\subsection{Unsafe Rust}
\begin{enumerate}
    \item Background on rest of the group?
    \item Things allowed by 'unsafe', causing holes in safety
\end{enumerate}

\subsection{Syntactic and Semantic correctness}
\begin{enumerate}
    \item Big idea: programmers aren't trying to write incorrect code. The programmer has some sort of internal argument for why their code is correct.
    \item Revisit restrictions of Safe Rust above
    \item Show that we can satisfy the semantic meaning of type safety guarantees even when the static type checker is overly restrictive
    \item Canonical examples: Cell, Mutex
    \item All code in our project should be "correct", that is, we want all of our code to have the properties of Safe Rust
    \item We should be able to find semantic correctness in our "unsafe" code
\end{enumerate}

\subsection{RustBelt for Unsafe Rust}
\begin{enumerate}
    \item Extensible safety (definition, how Rustbelt ensures it, why it matters for our project)
    \item Generate obligations that user must prove hold before they can say that the implemented API is "safe"
    \item Verify that an implementation actually implements the API
    \item Most judgements/proof obligations made at the typing layer
\end{enumerate}

\section{Plan}
\subsection{Isolation and Categorization}
\begin{enumerate}
    \item Locate and isolate instances of "unsafe" in codebase
    \item Categorize different patterns
    \item (maybe?) reduce size to smallest necessary unsafe block
\end{enumerate}

\subsection{Verification}
\begin{enumerate}
    \item Data structures (starting w/TakeCell) by extending RustBelt
    \item ??
\end{enumerate}

\section{Timeline}
Before I graduate

\section{Related Work/Alternative approaches}
Fill this in with details from the presentation
\begin{enumerate}
    \item Improved static checking
    \begin{itemize}
        \item More complicated static checking drastically increases runtime which decreases usability.
        \item Current systems can't automatically reason about certain things
    \end{itemize}
    
    \item Software testing
    
    \item Problem detection/mitigation
    
    \item Alex's project
    
\end{enumerate}

\section{Summary}

\section{References}

\end{document}
