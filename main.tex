\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Thesis Proposal}
\author{Elijah Rivera}
\date{November 2019}

\begin{document}

\maketitle

\section{Abstract}

\section{Introduction}

%NHB: in the intro don't use explicit subsections
%this is less of a threat model, and more a lay of the land outlining problems.
%Explicit threat modeling for your defense, ie, what reviewers should judge you
%against, comes later.
\subsection{Threat Model?}
A.k.a. scare tactics

%NHB: these are what rustbelt actually addresses. For your proposal lets thing
%big: extensions to the rustbelt proofs -- is this actually
%the desirable set of things to verify?? What would an ideal set of proofs be?
%You can sketch out a bigger problem than we'll have time to solve -- but
%thinking about how to push further than Rustbelt is invaluable.
\subsection{Common errors}

\begin{enumerate}
    \item Memory errors
        \begin{itemize}
            \item Null dereference
            \item Use-after-free
            \item Aliasing/Mutation (race conditions)
        \end{itemize}
    \item Data races
    \item Dangers of having these problems
\end{enumerate}

In the past decade, memory errors have comprised $\sim70\%$ of discovered vulnerabilities. These errors includes (but is not limited to) dereferencing null pointers, accessing memory after it has been deallocated/freed (also known as use-after-free), or accessing memory before it has been initialized. 

Concurrent programs also have additional opportunities for error with data races (explain data races here).

Reasoning about these errors is difficult. Tools continue to be developed which help in detecting/mitigating these errors, but we still continue to see memory errors and data races in software systems of every scale. We also see how these errors can be exploited into large vulnerabilities. (give examples here)

\subsection{Rust}
\begin{enumerate}
    \item Safety model
    \item Memory safety as type safety, statically check
\end{enumerate}

The programming language Rust has recently seen increased usage in the computer systems community because it claims to statically prevent the above errors. Specifically, the developers claim that (quote the nomicon here).

(Rust's approach to memory safety)

(Rust's approach to lifetimes)

Because these are encoded into the type system, we can statically type-check our program. If the program passes, then the memory and lifetime guarantees must hold and our program is memory safe.

\subsection{Unsafe Rust}
\begin{enumerate}
    \item Syntactic restrictions prevent low-level programming paradigms
    \item Unsafe as an escape hatch
    \item Brings us back to C levels of safety (so none)
\end{enumerate}

Low-level systems code has operations that would break these syntactic restrictions. For operating systems (the context for the rest of this paper), these include (types of Unsafe Rust). These operations are restricted by the type-checker and therefore do not compile. Rust provides a backdoor in the form of the keyword "unsafe".

%NHB: this is the "state-of-the-art" section of your intro. Highlight the
%contributions they made, but also show the remaining gaps. You've identified
%and motivated a problem by, show that the state-of-the-art doesn't solve it.
\subsection{RustBelt}
\begin{enumerate}
    \item First, is (safe) Rust as safe as it claims to be?
    \item Is the Rust "extensible" model of safety valid for unsafe programs as well?
    \item Syntactic vs. semantic correctness
\end{enumerate}

%NHB: can we extend the rustbelt proofs to new properties? Can we extend them
%(or perhaps a subset) to construts that Rustbelt can't currently handle? What
%are the boundaries of Rustbelt, and how can we push them out.
\subsection{Our contribution}
\begin{enumerate}
    \item Patterns of Unsafe Rust in systems code
    \item Verified implementation for ZKOS (data structures, other)
    \item ??
\end{enumerate}

%NHB: Side note: it's okay to have a master thesis that focuses this much on
%rustbelt.  for a conference paper you'd want to be more agressive about
%claiming new ground and showing additional contributions (vice extensions) to
%rustbelt. Guard against this becoming an ode to rustbelt, or excessively focued
%on what they've done instead of what you've done.

\section{Background}
\subsection{Safety of Rust}
\begin{enumerate}
    \item In-depth safety model
    \begin{itemize}
        \item Memory safety as type safety
        \item Static checking/guarantees
        \item Limitations
        \item Restrictions
    \end{itemize}
    \item Proven correct by RustBelt
    \begin{itemize}
        %NHB: and also highlight why it may *not* be enough, and give more depth
        %on the remaining problems we will address
        \item This is a stronger claim than what is actually true. This paragraph should talk about what RustBelt actually verifies, and why that's still enough for us.
    \end{itemize}
\end{enumerate}

\subsection{Unsafe Rust}
%NHB: be sure to highight uses of unsafe by OS, and why they differ from user
%space code that RustBelt focused on.
\begin{enumerate}
    \item Background on rest of the group?
    \item Things allowed by 'unsafe', causing holes in safety
\end{enumerate}

\subsection{Syntactic and Semantic correctness}
\begin{enumerate}
    \item Big idea: programmers aren't trying to write incorrect code. The programmer has some sort of internal argument for why their code is correct.
    \item Revisit restrictions of Safe Rust above
    \item Show that we can satisfy the semantic meaning of type safety guarantees even when the static type checker is overly restrictive
    \item Canonical examples: Cell, Mutex
    \item All code in our project should be "correct", that is, we want all of our code to have the properties of Safe Rust
    \item We should be able to find semantic correctness in our "unsafe" code
\end{enumerate}

\subsection{RustBelt for Unsafe Rust}
\begin{enumerate}
    \item Extensible safety (definition, how Rustbelt ensures it, why it matters for our project)
    \item Generate obligations that user must prove hold before they can say that the implemented API is "safe"
    \item Verify that an implementation actually implements the API
    \item Most judgements/proof obligations made at the typing layer
\end{enumerate}

\section{Plan}

%NHB: emphasize that OS code has unique requirements for unsafe that need to be
%addressed
\subsection{Isolation and Categorization}
\begin{enumerate}
    \item Locate and isolate instances of "unsafe" in codebase
    \item Categorize different patterns
    \item (maybe?) reduce size to smallest necessary unsafe block
\end{enumerate}

%NHB: highlight things that come out of this case study for differences with
%rustbelt / new things for OS code.
\subsection{Verification}
\begin{enumerate}
    \item Data structures (starting w/TakeCell) by extending RustBelt
    \item ??
\end{enumerate}

\section{Timeline}
Before I graduate

\section{Related Work/Alternative approaches}
Fill this in with details from the presentation
\begin{enumerate}
    \item Improved static checking
    \begin{itemize}
        \item More complicated static checking drastically increases runtime which decreases usability.
        \item Current systems can't automatically reason about certain things
    \end{itemize}
    
    \item Software testing
    
    \item Problem detection/mitigation
    
    \item Alex's project
    
\end{enumerate}

\section{Summary}

\section{References}

\end{document}
