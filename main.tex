\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Thesis Proposal}
\author{Elijah Rivera}
\date{November 2019}

\begin{document}

\maketitle

\section{Abstract}

\section{Introduction}
\subsection{Threat Model?}
A.k.a. scare tactics

\subsection{Memory problems}
\begin{itemize}
    \item Null dereference
    \item Use-after-free
    \item Aliasing/Mutation (race conditions)
\end{itemize}

\subsection{Rust}
\begin{enumerate}
    \item Safety model
    \item Memory safety as type safety, statically check
\end{enumerate}

\subsection{Unsafe Rust}
\begin{enumerate}
    \item Syntactic restrictions prevent low-level programming paradigms
    \item Unsafe as an escape hatch
    \item Brings us back to C levels of safety (so none)
\end{enumerate}

\subsection{RustBelt}
\begin{enumerate}
    \item First, is (safe) Rust as safe as it claims to be?
    \item Is the Rust "extensible" model of safety valid for unsafe programs as well?
    \item Syntactic vs. semantic correctness
\end{enumerate}

\subsection{Our contribution}
\begin{enumerate}
    \item Patterns of Unsafe Rust in systems code
    \item Verified implementation for ZKOS (data structures, other)
    \item ??
\end{enumerate}

\section{Background}
\subsection{Safety of Rust}
\begin{enumerate}
    \item In-depth safety model
    \begin{itemize}
        \item Memory safety as type safety
        \item Static checking/guarantees
        \item Limitations
        \item Restrictions
    \end{itemize}
    \item Proven correct by RustBelt
    \begin{itemize}
        \item This is a stronger claim than what is actually true. This paragraph should talk about what RustBelt actually verifies, and why that's still enough for us.
    \end{itemize}
\end{enumerate}

\subsection{Unsafe Rust}
\begin{enumerate}
    \item Background on rest of the group?
    \item Things allowed by 'unsafe', causing holes in safety
\end{enumerate}

\subsection{Syntactic and Semantic correctness}
\begin{enumerate}
    \item Big idea: programmers aren't trying to write incorrect code. The programmer has some sort of internal argument for why their code is correct.
    \item Revisit restrictions of Safe Rust above
    \item Show that we can satisfy the semantic meaning of type safety guarantees even when the static type checker is overly restrictive
    \item Canonical examples: Cell, Mutex
    \item All code in our project should be "correct", that is, we want all of our code to have the properties of Safe Rust
    \item We should be able to find semantic correctness in our "unsafe" code
\end{enumerate}

\subsection{RustBelt for Unsafe Rust}
\begin{enumerate}
    \item Extensible safety (definition, how Rustbelt ensures it, why it matters for our project)
    \item Generate obligations that user must prove hold before they can say that the implemented API is "safe"
    \item Verify that an implementation actually implements the API
    \item Most judgements/proof obligations made at the typing layer
\end{enumerate}

\section{Plan}
\subsection{Isolation and Categorization}
\begin{enumerate}
    \item Locate and isolate instances of "unsafe" in codebase
    \item Categorize different patterns
    \item (maybe?) reduce size to smallest necessary unsafe block
\end{enumerate}

\subsection{Verification}
\begin{enumerate}
    \item Data structures (starting w/TakeCell) by extending RustBelt
    \item ??
\end{enumerate}

\section{Timeline}
Before I graduate

\section{Related Work/Alternative approaches}
Fill this in with details from the presentation
\begin{enumerate}
    \item Improved static checking
    \begin{itemize}
        \item More complicated static checking drastically increases runtime which decreases usability.
        \item Current systems can't automatically reason about certain things
    \end{itemize}
    
    \item Software testing
    
    \item Problem detection/mitigation
    
    \item Alex's project
    
\end{enumerate}

\section{Summary}

\section{References}

\end{document}
